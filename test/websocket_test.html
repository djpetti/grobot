<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>test_el-element test</title>

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../bower_components/polymer-redux/polymer-redux.js"></script>
    <script src="../bower_components/redux/index.js"></script>
    <script src="../src/js/actions.js"></script>
    <script src="../src/js/gb-action-panel-messages.js"></script>
    <script src="../src/js/main.js"></script>
    <script src="../src/js/websockets.js"></script>

    <script src="fake_redux.js"></script>

    <link rel="import" href="../src/gb-action-panel.html">
  </head>
  <body>
    <script>
      suite('actions.js', function() {
        // The websockets.Backend instance to use for testing.
        var socketHandler;

				setup(function() {
          // Initialize fake Redux state for testing.
          fakeRedux.store.initFakeState();

          socketHandler = new websockets.Backend(true);

          // Replace the socket with a mock that we can use for testing.
          let fakeSocket = class {
            constructor() {
              // Stores send messages.
              this.messages_ = [];
            }

            send(message) {
              // Record the message.
              this.messages_.push(message);
            }

            getMessages() {
              // Get the current messages.
              return this.messages_;
            }
          };

          // Replace the real socket with a fake one.
          socketHandler.socket = new fakeSocket();
        });

        test('it ignores a message with an invalid type.',
             function(done) {
          // Capture the initial state so we can be sure it doesn't change.
          const initialState = main.getReduxStore().getState();

          // Send an invalid action.
          const message = {type: 'invalid'};
          assert.throws(function() {
              socketHandler.processMessage_(message)
          }, TypeError);

          // Nothing should happen.
          const actions = main.getReduxStore().getDispatchedActions();
          assert.equal(0, actions.length);

          done();
        });

        test('Redux reflects a state update request.',
             function(done) {
          // Send a message with an updated state.
          let message = {type: 'state', key: ['mcu_alive'], state: true};
          socketHandler.processMessage_(message);

          // We should see an action marking it as alive.
          let actions = main.getReduxStore().getDispatchedActions();
          assert.equal(1, actions.length);
          assert.deepEqual(['mcu_alive'], actions[0].key);
          assert.isTrue(actions[0].state);

          // Mark it as dead now.
          message.state = false;
          socketHandler.processMessage_(message);

          // We should see an action marking it as dead.
          actions = main.getReduxStore().getDispatchedActions();
          assert.equal(2, actions.length);
          assert.deepEqual(['mcu_alive'], actions[1].key);
          assert.isFalse(actions[1].state);

          done();
        });

        test('Websockets handles a state_change message correctly.',
             function(done) {
          // Fake a state change message.
          const message = {type: 'state_change', key: ['mcu_alive']};
          socketHandler.processMessage_(message);

          // We should see no actions.
          const actions = main.getReduxStore().getDispatchedActions();
          assert.equal(0, actions.length);

          // A response message should have been written.
          const responseMessage = socketHandler.socket.getMessages()[0];
          const expected = {type: 'state', key: ['mcu_alive']};
          assert.deepEqual(JSON.stringify(expected), responseMessage);

          done();
        });
      });
    </script>
  </body>
</html>
